<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GEON Explorer</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
  /* ── Theme variables ─────────────────────────────────────── */
  :root {
    --bg: #0f1117;
    --surface: #1a1d27;
    --surface2: #242836;
    --border: #2e3344;
    --text: #e1e4ed;
    --text-dim: #8b8fa3;
    --accent: #6c8cff;
    --accent-dim: #4a6ae0;
    --green: #4ade80;
    --orange: #fb923c;
    --red: #f87171;
    --shadow: rgba(0,0,0,0.4);
    --font-mono: 'SF Mono', 'Cascadia Code', 'Fira Code', 'Consolas', monospace;
    --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    /* Syntax */
    --syn-key: #6c8cff;
    --syn-value: #e1e4ed;
    --syn-list: #4ade80;
    --syn-coord: #fb923c;
    --syn-comment: #8b8fa3;
    --syn-section: #c084fc;
  }

  :root.light {
    --bg: #f5f6f8;
    --surface: #ffffff;
    --surface2: #ebedf2;
    --border: #d1d5e0;
    --text: #1a1d27;
    --text-dim: #5c6070;
    --accent: #4a6ae0;
    --accent-dim: #3a58c4;
    --green: #16a34a;
    --orange: #d97706;
    --red: #dc2626;
    --shadow: rgba(0,0,0,0.1);
    /* Syntax */
    --syn-key: #2f54c9;
    --syn-value: #1a1d27;
    --syn-list: #16713a;
    --syn-coord: #b45309;
    --syn-comment: #6b7085;
    --syn-section: #7c3aed;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: var(--font-sans);
    background: var(--bg);
    color: var(--text);
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    transition: background 0.25s, color 0.25s;
  }

  /* ── Header ──────────────────────────────────────────────── */
  header {
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 10px 20px;
    display: flex;
    align-items: center;
    gap: 12px;
    flex-shrink: 0;
  }

  header h1 {
    font-size: 18px;
    font-weight: 600;
    letter-spacing: -0.02em;
  }

  header .logo {
    height: 44px;
    width: auto;
    object-fit: contain;
    border-radius: 8px;
    box-shadow: 0 6px 18px var(--shadow);
  }

  header h1 span { color: var(--accent); }

  header .subtitle {
    color: var(--text-dim);
    font-size: 13px;
    flex: 1;
  }

  .nav-links { display: flex; gap: 4px; }

  .nav-link {
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text-dim);
    padding: 6px 14px;
    border-radius: 6px;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.15s;
    text-decoration: none;
    font-family: var(--font-sans);
  }

  .nav-link:hover { color: var(--text); border-color: var(--accent); }
  .nav-link.active { color: var(--accent); border-color: var(--accent); background: var(--bg); }

  .theme-toggle {
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text-dim);
    width: 34px; height: 34px;
    border-radius: 6px;
    font-size: 16px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
    line-height: 1;
  }

  .theme-toggle:hover { color: var(--text); border-color: var(--accent); }

  /* ── Main layout ─────────────────────────────────────────── */
  .main { flex: 1; display: flex; overflow: hidden; }

  .left-panel { flex: 1; display: flex; flex-direction: column; min-width: 0; }

  .toolbar {
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 10px 16px;
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
    flex-shrink: 0;
  }

  .toolbar label {
    font-size: 12px; color: var(--text-dim);
    font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em;
  }

  .toolbar select, .toolbar input {
    background: var(--surface2); border: 1px solid var(--border);
    color: var(--text); padding: 6px 10px; border-radius: 6px;
    font-size: 13px; font-family: var(--font-sans);
  }

  .toolbar select:focus, .toolbar input:focus { outline: none; border-color: var(--accent); }
  .toolbar input[type="text"] { width: 220px; }
  .toolbar .spacer { flex: 1; }

  .btn {
    background: var(--accent); color: #fff; border: none;
    padding: 7px 16px; border-radius: 6px; font-size: 13px;
    font-weight: 500; cursor: pointer; transition: background 0.15s; white-space: nowrap;
  }

  .btn:hover { background: var(--accent-dim); }
  .btn:disabled { opacity: 0.4; cursor: not-allowed; }

  .btn-secondary {
    background: var(--surface2); border: 1px solid var(--border); color: var(--text);
  }

  .btn-secondary:hover { border-color: var(--accent); background: var(--surface); }

  /* ── Map ─────────────────────────────────────────────────── */
  #map { width: 100%; height: 100%; }
  .leaflet-container { background: var(--surface2); }

  .drop-overlay {
    display: none; position: absolute; inset: 0; z-index: 1000;
    background: rgba(108, 140, 255, 0.12); border: 3px dashed var(--accent);
    border-radius: 12px; align-items: center; justify-content: center; pointer-events: none;
  }

  .drop-overlay.active { display: flex; }

  .drop-overlay span {
    background: var(--surface); color: var(--accent);
    padding: 16px 32px; border-radius: 10px; font-size: 16px; font-weight: 600;
  }

  /* ── Right panel ─────────────────────────────────────────── */
  .right-panel {
    width: 520px; min-width: 360px; display: flex;
    flex-direction: column; border-left: 1px solid var(--border); flex-shrink: 0;
  }

  .panel-tabs {
    display: flex; background: var(--surface);
    border-bottom: 1px solid var(--border); flex-shrink: 0;
  }

  .panel-tab {
    padding: 10px 20px; font-size: 13px; font-weight: 500;
    color: var(--text-dim); cursor: pointer; border-bottom: 2px solid transparent;
    transition: all 0.15s; background: none; border-top: none;
    border-left: none; border-right: none; font-family: var(--font-sans);
  }

  .panel-tab:hover { color: var(--text); }
  .panel-tab.active { color: var(--accent); border-bottom-color: var(--accent); }

  .panel-actions {
    display: flex; gap: 8px; padding: 8px 12px;
    background: var(--surface); border-bottom: 1px solid var(--border); flex-shrink: 0;
  }

  .panel-actions .btn { font-size: 12px; padding: 5px 12px; }

  .output-area { flex: 1; overflow: auto; padding: 0; position: relative; min-height: 0; }

  .output-area pre {
    font-family: var(--font-mono); font-size: 13px; line-height: 1.6;
    padding: 16px; margin: 0; white-space: pre-wrap; word-break: break-word;
  }

  .output-area .empty-state {
    display: flex; flex-direction: column; align-items: center;
    justify-content: center; height: 100%; color: var(--text-dim);
    padding: 40px; text-align: center;
  }

  .empty-state .icon { font-size: 48px; margin-bottom: 16px; opacity: 0.3; }
  .empty-state p { font-size: 14px; line-height: 1.6; max-width: 300px; }
  .empty-state .hint { font-size: 12px; margin-top: 12px; color: var(--text-dim); opacity: 0.7; }

  .validation-bar {
    padding: 8px 12px; background: var(--surface); border-top: 1px solid var(--border);
    font-size: 12px; display: flex; gap: 12px; flex-shrink: 0;
  }

  .badge { padding: 2px 8px; border-radius: 4px; font-weight: 500; }
  .badge-ok { background: rgba(74, 222, 128, 0.15); color: var(--green); }
  .badge-warn { background: rgba(251, 146, 60, 0.15); color: var(--orange); }
  .badge-err { background: rgba(248, 113, 113, 0.15); color: var(--red); }

  .status-bar {
    background: var(--surface); border-top: 1px solid var(--border);
    padding: 6px 16px; font-size: 11px; color: var(--text-dim);
    display: flex; gap: 16px; flex-shrink: 0;
  }

  .status-bar .sep { color: var(--border); }

  /* ── Syntax highlighting ─────────────────────────────────── */
  .geon-key { color: var(--syn-key); font-weight: 600; }
  .geon-value { color: var(--syn-value); }
  .geon-list { color: var(--syn-list); }
  .geon-coord { color: var(--syn-coord); }
  .geon-comment { color: var(--syn-comment); }
  .geon-section { color: var(--syn-section); font-weight: 600; }

  .spinner {
    display: inline-block; width: 14px; height: 14px;
    border: 2px solid var(--border); border-top-color: var(--accent);
    border-radius: 50%; animation: spin 0.6s linear infinite;
    vertical-align: middle; margin-right: 6px;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  .geojson-input { display: none; flex: 1; min-height: 0; }

  .geojson-input textarea {
    width: 100%; height: 100%; background: var(--bg); color: var(--text);
    border: none; padding: 16px; font-family: var(--font-mono);
    font-size: 13px; line-height: 1.6; resize: none; outline: none;
  }

  .geojson-input textarea::placeholder { color: var(--text-dim); opacity: 0.5; }

  /* ── Modal ───────────────────────────────────────────────── */
  .modal-overlay {
    display: none; position: fixed; inset: 0; z-index: 2000;
    background: rgba(0, 0, 0, 0.5); align-items: center; justify-content: center;
  }

  .modal-overlay.active { display: flex; }

  .modal {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 12px; padding: 28px; max-width: 560px;
    width: 90%; max-height: 80vh; overflow-y: auto;
  }

  .modal h2 { font-size: 18px; margin-bottom: 16px; }
  .modal h3 { font-size: 14px; margin: 16px 0 8px; color: var(--accent); }
  .modal p, .modal li { font-size: 13px; line-height: 1.7; color: var(--text-dim); }
  .modal ul { padding-left: 20px; }
  .modal code { font-family: var(--font-mono); color: var(--accent); font-size: 12px; }
  .modal .close-btn { margin-top: 20px; }

  /* ── Map popups ──────────────────────────────────────────── */
  .leaflet-popup-content-wrapper {
    background: var(--surface) !important; color: var(--text) !important;
    border-radius: 8px !important; border: 1px solid var(--border) !important;
    box-shadow: 0 8px 24px var(--shadow) !important;
  }

  .leaflet-popup-tip { background: var(--surface) !important; }

  .leaflet-popup-content {
    font-size: 13px !important; line-height: 1.5 !important; margin: 10px 14px !important;
  }

  .leaflet-popup-content b { color: var(--accent); }
  .leaflet-popup-content .popup-type { color: var(--text-dim); font-size: 11px; text-transform: uppercase; letter-spacing: 0.05em; }

  .popup-btn {
    display: inline-block; margin-top: 8px; background: var(--accent);
    color: #fff; border: none; padding: 5px 14px; border-radius: 5px;
    font-size: 12px; cursor: pointer; font-family: var(--font-sans);
  }

  .popup-btn:hover { background: var(--accent-dim); }

  .resize-handle {
    width: 4px; cursor: col-resize; background: var(--border);
    transition: background 0.15s; flex-shrink: 0;
  }

  .resize-handle:hover { background: var(--accent); }
</style>
</head>
<body>

<header>
  <img class="logo" src="../assets/logo.png" alt="GEON logo">
  <h1><span>GEON</span> Explorer</h1>
  <span class="subtitle">Geospatial Experience-Oriented Notation</span>
  <nav class="nav-links">
    <a class="nav-link" href="index.html">About</a>
    <a class="nav-link active" href="explore.html">Map</a>
    <a class="nav-link" href="form.html">Build</a>
    <button class="nav-link" onclick="toggleHelp()">Help</button>
  </nav>
  <button class="theme-toggle" id="themeBtn" onclick="toggleTheme()" title="Toggle light/dark theme">&#9790;</button>
</header>

<div class="main">
  <div class="left-panel" id="leftPanel">
    <div class="toolbar">
      <label>Mode:</label>
      <select id="modeSelect" onchange="switchMode()">
        <option value="click">Click Map</option>
        <option value="search">Search OSM</option>
        <option value="geojson">Paste GeoJSON</option>
      </select>

      <div id="searchGroup" style="display:none; position:relative;">
        <input type="text" id="searchInput" placeholder="e.g. Nottingham Castle" onkeydown="if(event.key==='Enter')doSearch()">
      </div>

      <button class="btn" id="searchBtn" style="display:none" onclick="doSearch()">Search</button>
      <button class="btn" id="convertBtn" style="display:none" onclick="convertPastedGeojson()">Convert to GEON</button>

      <span class="spacer"></span>

      <label id="radiusLabel">Radius:</label>
      <select id="radiusSelect">
        <option value="100">100m</option>
        <option value="250" selected>250m</option>
        <option value="500">500m</option>
        <option value="1000">1km</option>
      </select>
    </div>

    <div id="mapContainer" style="flex:1; position:relative;">
      <div id="map"></div>
      <div class="drop-overlay" id="dropOverlay"><span>Drop GeoJSON file here</span></div>
    </div>

    <div class="geojson-input" id="geojsonInput">
      <textarea id="geojsonTextarea" placeholder='Paste GeoJSON here...&#10;&#10;{&#10;  "type": "Feature",&#10;  "geometry": {&#10;    "type": "Point",&#10;    "coordinates": [-1.1581, 52.9548]&#10;  },&#10;  "properties": {&#10;    "name": "Market Square"&#10;  }&#10;}'></textarea>
    </div>
  </div>

  <div class="resize-handle" id="resizeHandle"></div>

  <div class="right-panel" id="rightPanel">
    <div class="panel-tabs">
      <button class="panel-tab active" data-tab="geon" onclick="switchTab('geon')">GEON Output</button>
      <button class="panel-tab" data-tab="geojson-out" onclick="switchTab('geojson-out')">GeoJSON</button>
      <button class="panel-tab" data-tab="tokens" onclick="switchTab('tokens')">Token Count</button>
    </div>
    <div class="panel-actions">
      <button class="btn btn-secondary" onclick="copyOutput()">Copy</button>
      <button class="btn btn-secondary" onclick="downloadGeon()">Download .geon</button>
      <span class="spacer"></span>
      <button class="btn btn-secondary" onclick="clearOutput()">Clear</button>
    </div>

    <div class="output-area" id="outputArea">
      <div class="empty-state" id="emptyState">
        <div class="icon">&#x1F30D;</div>
        <p>Click anywhere on the map to fetch nearby OSM features and convert them to GEON format.</p>
        <p class="hint">You can also search by name, paste GeoJSON, or drag-and-drop a .geojson file onto the map.</p>
      </div>
      <pre id="outputPre" style="display:none"></pre>
    </div>

    <div class="validation-bar" id="validationBar" style="display:none">
      <span id="validBadge"></span>
      <span id="warnBadge"></span>
      <span id="fieldsBadge"></span>
    </div>
  </div>
</div>

<div class="status-bar">
  <span id="statusCoords">--</span>
  <span class="sep">|</span>
  <span id="statusInfo">Click map to begin</span>
  <span class="sep">|</span>
  <span>GEON v0.1.0</span>
  <span class="sep">|</span>
  <span>James Williams &mdash; University of Nottingham</span>
</div>

<!-- Help modal -->
<div class="modal-overlay" id="helpModal">
  <div class="modal">
    <h2>GEON Explorer</h2>
    <p>An interactive demo for the <b>Geospatial Experience-Oriented Notation</b> format.</p>

    <h3>Click Map</h3>
    <p>Click anywhere on the map to query nearby OpenStreetMap features via the Overpass API. Click a marker to convert it to GEON.</p>

    <h3>Search OSM</h3>
    <p>Type a place name and hit Search. Results from Nominatim appear on the map.</p>

    <h3>Build (Form)</h3>
    <p>Use the <b>Build</b> page to manually fill out every GEON field with a structured form. Great for creating detailed place descriptions from scratch.</p>

    <h3>Paste / Drop GeoJSON</h3>
    <ul>
      <li>Switch to "Paste GeoJSON" mode and paste any valid GeoJSON.</li>
      <li>Or drag-and-drop a <code>.geojson</code> / <code>.json</code> file onto the map.</li>
    </ul>

    <h3>About</h3>
    <p>Developed by <b>James Williams</b> at the <b>University of Nottingham</b>.</p>
    <p>GEON Specification v0.1.0 &mdash; February 2026. Licensed under CC BY 4.0.</p>

    <button class="btn close-btn" onclick="toggleHelp()">Got it</button>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
// ── Theme ────────────────────────────────────────────────────────────────

const TILE_DARK = 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
const TILE_LIGHT = 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png';
const TILE_ATTR = '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> &copy; <a href="https://carto.com/">CARTO</a>';

let currentTheme = localStorage.getItem('geon-theme') || 'dark';
let tileLayer;

function applyTheme(theme) {
  currentTheme = theme;
  document.documentElement.classList.toggle('light', theme === 'light');
  document.getElementById('themeBtn').innerHTML = theme === 'dark' ? '&#9790;' : '&#9788;';
  localStorage.setItem('geon-theme', theme);

  if (tileLayer) {
    tileLayer.setUrl(theme === 'dark' ? TILE_DARK : TILE_LIGHT);
  }
}

function toggleTheme() {
  applyTheme(currentTheme === 'dark' ? 'light' : 'dark');
}

// Apply saved theme immediately
applyTheme(currentTheme);

// ── Map setup ────────────────────────────────────────────────────────────

const map = L.map('map', { zoomControl: true }).setView([52.9548, -1.1581], 14);

tileLayer = L.tileLayer(currentTheme === 'dark' ? TILE_DARK : TILE_LIGHT, {
  attribution: TILE_ATTR, maxZoom: 19,
}).addTo(map);

setTimeout(() => map.invalidateSize(), 200);

let markers = L.layerGroup().addTo(map);
let polygons = L.layerGroup().addTo(map);
let currentGeon = '';
let currentGeojson = '';
let currentTab = 'geon';

// ── Map click ────────────────────────────────────────────────────────────

map.on('click', async (e) => {
  if (document.getElementById('modeSelect').value !== 'click') return;
  const { lat, lng } = e.latlng;
  document.getElementById('statusCoords').textContent = `${lat.toFixed(5)}, ${lng.toFixed(5)}`;
  const radius = document.getElementById('radiusSelect').value;
  setStatus(`<span class="spinner"></span> Querying OSM within ${radius}m...`);

  try {
    const data = await queryOverpass(lat, lng, parseInt(radius));
    if (!data.elements || data.elements.length === 0) {
      setStatus('No features found. Try a larger radius.');
      return;
    }
    markers.clearLayers(); polygons.clearLayers();
    const named = data.elements.filter(el => el.tags && el.tags.name);
    const toShow = named.length > 0 ? named : data.elements.slice(0, 10);
    setStatus(`Found ${toShow.length} feature(s)`);

    toShow.forEach(el => {
      const coord = getElementCoord(el);
      if (!coord) return;
      const name = (el.tags && el.tags.name) || `${el.type}/${el.id}`;
      const type = inferType(el.tags || {});
      const marker = L.circleMarker([coord.lat, coord.lon], {
        radius: 8, color: '#6c8cff', fillColor: '#6c8cff', fillOpacity: 0.7, weight: 2,
      }).addTo(markers);
      marker.bindPopup(`
        <div class="popup-type">${type}</div>
        <b>${escHtml(name)}</b><br>
        <button class="popup-btn" onclick="convertElement(${JSON.stringify(el).replace(/"/g, '&quot;')})">Convert to GEON</button>
      `);
      if (el.type === 'way' && el.geometry) {
        L.polyline(el.geometry.map(p => [p.lat, p.lon]), { color: '#6c8cff', weight: 2, opacity: 0.5 }).addTo(polygons);
      }
    });
    if (toShow.length > 0) convertElement(toShow[0]);
  } catch (err) { setStatus(`Error: ${err.message}`); }
});

map.on('mousemove', (e) => {
  document.getElementById('statusCoords').textContent = `${e.latlng.lat.toFixed(5)}, ${e.latlng.lng.toFixed(5)}`;
});

// ── Overpass ─────────────────────────────────────────────────────────────

async function queryOverpass(lat, lon, radius) {
  const query = `[out:json][timeout:10];(node(around:${radius},${lat},${lon})["name"];way(around:${radius},${lat},${lon})["name"];);out body geom 15;`;
  const resp = await fetch('https://overpass-api.de/api/interpreter', {
    method: 'POST', body: `data=${encodeURIComponent(query)}`,
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
  });
  if (!resp.ok) throw new Error(`Overpass returned ${resp.status}`);
  return resp.json();
}

function getElementCoord(el) {
  if (el.type === 'node') return { lat: el.lat, lon: el.lon };
  if (el.center) return { lat: el.center.lat, lon: el.center.lon };
  if (el.bounds) return { lat: (el.bounds.minlat + el.bounds.maxlat) / 2, lon: (el.bounds.minlon + el.bounds.maxlon) / 2 };
  if (el.geometry && el.geometry.length > 0) {
    const lats = el.geometry.map(p => p.lat), lons = el.geometry.map(p => p.lon);
    return { lat: lats.reduce((a, b) => a + b) / lats.length, lon: lons.reduce((a, b) => a + b) / lons.length };
  }
  return null;
}

// ── Element -> GEON ──────────────────────────────────────────────────────

function convertElement(el) {
  const tags = el.tags || {};
  const coord = getElementCoord(el);
  if (!coord) return;
  const place = {
    name: tags.name || tags['name:en'] || `${el.type}/${el.id}`,
    type: inferType(tags), id: `osm:${el.type}/${el.id}`,
    location: coord,
    boundary: (el.type === 'way' && el.geometry) ? el.geometry.map(p => ({lat: p.lat, lon: p.lon})) : [],
    purposes: inferPurposes(tags), tags: tags,
  };
  currentGeon = generateGeon(place);
  currentGeojson = generateGeojson(place);
  showOutput();
  setStatus(`Converted: ${place.name}`);
}

// ── GEON generator ───────────────────────────────────────────────────────

function generateGeon(place) {
  let out = '';
  out += `PLACE: ${place.name}\n`;
  out += `TYPE: ${place.type}\n`;
  if (place.id) out += `ID: ${place.id}\n`;
  out += `LOCATION: ${place.location.lat.toFixed(5)}, ${place.location.lon.toFixed(5)}\n`;
  if (place.boundary && place.boundary.length >= 3) {
    out += 'BOUNDARY:\n';
    place.boundary.forEach(c => { out += `  - ${c.lat.toFixed(5)}, ${c.lon.toFixed(5)}\n`; });
  }
  if (place.tags && place.tags.area) out += `AREA: ${place.tags.area}\n`;
  if (place.tags && place.tags.ele) out += `ELEVATION: ${place.tags.ele}m above sea level\n`;
  if (place.purposes && place.purposes.length > 0) {
    out += 'PURPOSE:\n';
    place.purposes.forEach(p => { out += `  - ${p}\n`; });
  }
  const exp = inferExperience(place.tags || {});
  if (Object.keys(exp).length > 0) {
    out += 'EXPERIENCE:\n';
    for (const [k, v] of Object.entries(exp)) out += `  ${k}: ${v}\n`;
  }
  const chars = [];
  if (place.tags) {
    if (place.tags.description) chars.push(place.tags.description);
    if (place.tags.historic) chars.push(`historic (${place.tags.historic})`);
    if (place.tags.heritage) chars.push(`heritage (${place.tags.heritage})`);
    if (place.tags.architect) chars.push(`designed by ${place.tags.architect}`);
    if (place.tags.architectural_style) chars.push(place.tags.architectural_style);
  }
  if (chars.length > 0) {
    out += 'CHARACTER:\n';
    chars.forEach(c => { out += `  - ${c}\n`; });
  }
  const conn = {};
  if (place.tags) {
    if (place.tags.bicycle) conn.cycling = place.tags.bicycle;
    if (place.tags.foot) conn.pedestrian = place.tags.foot;
    if (place.tags.bus) conn.bus = place.tags.bus === 'yes' ? 'available' : place.tags.bus;
    if (place.tags.railway) conn.rail = place.tags.railway;
    if (place.tags.access) conn.access = place.tags.access;
  }
  if (Object.keys(conn).length > 0) {
    out += 'CONNECTIVITY:\n';
    for (const [k, v] of Object.entries(conn)) out += `  ${k}: ${v}\n`;
  }
  if (place.tags && place.tags.opening_hours) {
    out += 'TEMPORAL:\n';
    out += `  opening_hours: ${place.tags.opening_hours}\n`;
  }
  out += 'SOURCE:\n';
  out += `  - OpenStreetMap (${place.id || 'live query'})\n`;
  out += `  - Overpass API (${new Date().toISOString().slice(0, 10)})\n`;
  return out;
}

function generateGeojson(place) {
  const feature = {
    type: 'Feature',
    geometry: place.boundary && place.boundary.length >= 3
      ? { type: 'Polygon', coordinates: [place.boundary.map(c => [c.lon, c.lat])] }
      : { type: 'Point', coordinates: [place.location.lon, place.location.lat] },
    properties: {
      name: place.name, geon_type: place.type,
      ...(place.id && { id: place.id }),
      ...(place.purposes.length > 0 && { purpose: place.purposes }),
    },
  };
  if (place.id) feature.id = place.id;
  return JSON.stringify(feature, null, 2);
}

// ── Type inference ───────────────────────────────────────────────────────

const TYPE_MAP = {
  park:'public_space',garden:'public_space',playground:'public_space',plaza:'public_space',
  marketplace:'public_space',pitch:'public_space',common:'public_space',recreation_ground:'public_space',
  road:'street',residential:'street',primary:'street',secondary:'street',tertiary:'street',
  footway:'street',pedestrian:'street',cycleway:'street',
  station:'transport_hub',railway_station:'transport_hub',bus_station:'transport_hub',airport:'transport_hub',halt:'transport_hub',
  yes:'building',house:'building',apartments:'building',commercial:'building',retail:'building',
  industrial:'building',office:'building',school:'building',church:'building',hospital:'building',
  university:'building',hotel:'building',
  monument:'landmark',memorial:'landmark',statue:'landmark',tower:'landmark',castle:'landmark',castle_wall:'landmark',ruins:'landmark',
  bridge:'threshold',
  river:'natural_feature',stream:'natural_feature',lake:'natural_feature',wood:'natural_feature',
  forest:'natural_feature',peak:'natural_feature',beach:'natural_feature',wetland:'natural_feature',cliff:'natural_feature',
};

function inferType(tags) {
  for (const key of ['building','highway','railway','leisure','amenity','natural','landuse','tourism','man_made','waterway','historic']) {
    const val = tags[key];
    if (val && TYPE_MAP[val]) return TYPE_MAP[val];
  }
  if (tags.building) return 'building';
  if (tags.leisure) return 'public_space';
  if (tags.highway) return 'street';
  if (tags.natural || tags.waterway) return 'natural_feature';
  if (tags.historic) return 'landmark';
  return 'hybrid';
}

function inferPurposes(tags) {
  const p = [];
  if (tags.amenity) p.push(tags.amenity.replace(/_/g, ' '));
  if (tags.leisure) p.push(tags.leisure.replace(/_/g, ' '));
  if (tags.shop) p.push(`retail (${tags.shop})`);
  if (tags.tourism) p.push(`tourism (${tags.tourism})`);
  if (tags.sport) p.push(`sport (${tags.sport})`);
  if (tags.cuisine) p.push(`food (${tags.cuisine})`);
  if (tags.healthcare) p.push(`health (${tags.healthcare})`);
  if (tags.religion) p.push(`worship (${tags.religion})`);
  return p;
}

function inferExperience(tags) {
  const exp = {};
  if (tags.lit === 'yes') exp.lighting = 'good';
  if (tags.lit === 'no') exp.lighting = 'none';
  if (tags.surface) exp.surface = tags.surface;
  if (tags.wheelchair === 'yes') exp.accessibility = 'high';
  if (tags.wheelchair === 'limited') exp.accessibility = 'medium';
  if (tags.wheelchair === 'no') exp.accessibility = 'low';
  if (tags.covered === 'yes') exp.enclosure = 'high';
  if (tags.indoor === 'yes') exp.enclosure = 'very_high';
  if (tags.leisure === 'park' || tags.leisure === 'garden') exp.openness = 'high';
  return exp;
}

function inferTypeFromProps(props) {
  for (const key of ['building','highway','railway','leisure','amenity','natural','landuse','tourism','man_made','waterway','historic','type','geon_type']) {
    const val = props[key];
    if (val && TYPE_MAP[val]) return TYPE_MAP[val];
  }
  if (props.geon_type) return props.geon_type;
  return 'hybrid';
}

function extractPurposes(props) {
  if (props.purpose) return Array.isArray(props.purpose) ? props.purpose : [props.purpose];
  return inferPurposes(props);
}

// ── GeoJSON paste / drop ─────────────────────────────────────────────────

function convertPastedGeojson() {
  const raw = document.getElementById('geojsonTextarea').value.trim();
  if (!raw) return;
  try { convertGeojsonObject(JSON.parse(raw)); }
  catch (err) { setStatus(`Invalid JSON: ${err.message}`); }
}

function convertGeojsonObject(geojson) {
  markers.clearLayers(); polygons.clearLayers();
  let features = [];
  if (geojson.type === 'FeatureCollection') features = geojson.features || [];
  else if (geojson.type === 'Feature') features = [geojson];
  else { setStatus('Unsupported GeoJSON type.'); return; }
  if (features.length === 0) { setStatus('No features.'); return; }

  let allGeon = '', allGeojson = JSON.stringify(geojson, null, 2);
  const bounds = [];

  features.forEach((f, idx) => {
    const props = f.properties || {}, geom = f.geometry || {};
    const coord = extractCentroid(geom);
    if (!coord) return;
    const place = {
      name: props.name || props['name:en'] || props.title || props.label || `Feature ${idx+1}`,
      type: inferTypeFromProps(props), id: f.id || props.id || props['@id'] || '',
      location: coord,
      boundary: geom.type === 'Polygon' ? geom.coordinates[0].map(c => ({lat:c[1],lon:c[0]})) : [],
      purposes: extractPurposes(props), tags: props,
    };
    allGeon += generateGeon(place) + '\n';
    bounds.push([coord.lat, coord.lon]);
    L.circleMarker([coord.lat, coord.lon], { radius: 8, color: '#6c8cff', fillColor: '#6c8cff', fillOpacity: 0.7, weight: 2 })
      .addTo(markers).bindPopup(`<b>${escHtml(place.name)}</b><br><span class="popup-type">${place.type}</span>`);
    if (geom.type === 'Polygon')
      L.polygon(geom.coordinates[0].map(c => [c[1], c[0]]), { color: '#6c8cff', weight: 2, fillOpacity: 0.1 }).addTo(polygons);
  });

  currentGeon = allGeon; currentGeojson = allGeojson;
  showOutput();
  if (bounds.length === 1) map.setView(bounds[0], 16);
  else if (bounds.length > 1) map.fitBounds(bounds, { padding: [40, 40] });
  setStatus(`Converted ${features.length} feature(s) to GEON`);
}

function extractCentroid(geom) {
  if (!geom || !geom.coordinates) return null;
  if (geom.type === 'Point') return { lat: geom.coordinates[1], lon: geom.coordinates[0] };
  if (geom.type === 'Polygon') {
    const r = geom.coordinates[0];
    return { lat: r.reduce((s,c) => s+c[1], 0)/r.length, lon: r.reduce((s,c) => s+c[0], 0)/r.length };
  }
  if (geom.type === 'MultiPolygon') {
    const r = geom.coordinates[0][0];
    return { lat: r.reduce((s,c) => s+c[1], 0)/r.length, lon: r.reduce((s,c) => s+c[0], 0)/r.length };
  }
  if (geom.type === 'LineString') { const m = geom.coordinates[Math.floor(geom.coordinates.length/2)]; return { lat: m[1], lon: m[0] }; }
  return null;
}

// ── Search (Nominatim) ───────────────────────────────────────────────────

async function doSearch() {
  const q = document.getElementById('searchInput').value.trim();
  if (!q) return;
  setStatus(`<span class="spinner"></span> Searching for "${escHtml(q)}"...`);
  try {
    const resp = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(q)}&format=json&limit=8&addressdetails=1`,
      { headers: { 'User-Agent': 'GEON-Explorer-Demo/0.1' } });
    const results = await resp.json();
    if (results.length === 0) { setStatus('No results found.'); return; }
    markers.clearLayers(); polygons.clearLayers();
    const bounds = [];
    results.forEach(r => {
      const lat = parseFloat(r.lat), lon = parseFloat(r.lon);
      bounds.push([lat, lon]);
      L.circleMarker([lat, lon], { radius: 8, color: '#6c8cff', fillColor: '#6c8cff', fillOpacity: 0.7, weight: 2 })
        .addTo(markers).bindPopup(`
          <div class="popup-type">${r.type || 'place'}</div>
          <b>${escHtml(r.display_name.split(',')[0])}</b><br>
          <small>${escHtml(r.display_name)}</small><br>
          <button class="popup-btn" onclick="convertNominatim(${JSON.stringify(r).replace(/"/g, '&quot;')})">Convert to GEON</button>`);
    });
    if (bounds.length > 0) map.fitBounds(bounds, { padding: [40, 40], maxZoom: 16 });
    setStatus(`Found ${results.length} result(s)`);
    if (results.length > 0) convertNominatim(results[0]);
  } catch (err) { setStatus(`Search error: ${err.message}`); }
}

function convertNominatim(result) {
  const place = {
    name: result.display_name.split(',')[0],
    type: inferType({ [result.class]: result.type, ...result }),
    id: `osm:${result.osm_type}/${result.osm_id}`,
    location: { lat: parseFloat(result.lat), lon: parseFloat(result.lon) },
    boundary: [], purposes: result.type ? [result.type.replace(/_/g, ' ')] : [],
    tags: { ...result.address, class: result.class, type: result.type },
  };
  if (result.boundingbox) {
    const [s, n, w, e] = result.boundingbox.map(parseFloat);
    place.boundary = [{lat:n,lon:w},{lat:n,lon:e},{lat:s,lon:e},{lat:s,lon:w},{lat:n,lon:w}];
  }
  currentGeon = generateGeon(place);
  currentGeojson = generateGeojson(place);
  showOutput();
  setStatus(`Converted: ${place.name}`);
}

// ── Drag and drop ────────────────────────────────────────────────────────

let dragCounter = 0;
document.body.addEventListener('dragenter', (e) => { e.preventDefault(); dragCounter++; document.getElementById('dropOverlay').classList.add('active'); });
document.body.addEventListener('dragleave', (e) => { e.preventDefault(); dragCounter--; if (dragCounter <= 0) { dragCounter = 0; document.getElementById('dropOverlay').classList.remove('active'); } });
document.body.addEventListener('dragover', (e) => { e.preventDefault(); });
document.body.addEventListener('drop', (e) => {
  e.preventDefault(); dragCounter = 0; document.getElementById('dropOverlay').classList.remove('active');
  const file = e.dataTransfer.files[0]; if (!file) return;
  const reader = new FileReader();
  reader.onload = () => { try { convertGeojsonObject(JSON.parse(reader.result)); } catch (err) { setStatus(`Invalid GeoJSON: ${err.message}`); } };
  reader.readAsText(file);
});

// ── Output display ───────────────────────────────────────────────────────

function showOutput() {
  document.getElementById('emptyState').style.display = 'none';
  document.getElementById('outputPre').style.display = 'block';
  document.getElementById('validationBar').style.display = 'flex';
  renderTab(); renderValidation();
}

function renderTab() {
  const pre = document.getElementById('outputPre');
  if (currentTab === 'geon') pre.innerHTML = highlightGeon(currentGeon);
  else if (currentTab === 'geojson-out') pre.innerHTML = escHtml(currentGeojson);
  else if (currentTab === 'tokens') pre.innerHTML = renderTokenComparison();
}

function highlightGeon(text) {
  return text.split('\n').map(line => {
    if (line.match(/^\s*-\s+(-?\d+\.\d+),\s*(-?\d+\.\d+)/))
      return `<span class="geon-list">  - </span><span class="geon-coord">${escHtml(line.replace(/^\s*-\s+/, ''))}</span>`;
    if (line.match(/^\s*-\s+/))
      return `<span class="geon-list">${escHtml(line)}</span>`;
    const m = line.match(/^(\s*)([\w_]+):\s*(.*)$/);
    if (m) {
      const [, indent, key, value] = m;
      const sections = ['PURPOSE','EXPERIENCE','CHARACTER','ADJACENCIES','CONNECTIVITY','CONTAINS','TEMPORAL','SOURCE','CONFIDENCE','BOUNDARY','VIEWSHEDS','BUILT_FORM','ECOLOGY','INFRASTRUCTURE','DEMOGRAPHICS','ECONOMY','LIFESPAN'];
      if (!value && sections.includes(key)) return `${indent}<span class="geon-section">${escHtml(key)}:</span>`;
      const isCoord = value.match(/^-?\d+\.\d+,\s*-?\d+\.\d+$/);
      return `${indent}<span class="geon-key">${escHtml(key)}:</span> <span class="${isCoord ? 'geon-coord' : 'geon-value'}">${escHtml(value)}</span>`;
    }
    return escHtml(line);
  }).join('\n');
}

function renderTokenComparison() {
  const gt = estimateTokens(currentGeon), jt = estimateTokens(currentGeojson);
  const saving = jt > 0 ? ((1 - gt/jt) * 100).toFixed(0) : '0';
  return `<span class="geon-section">TOKEN COMPARISON</span>
<span class="geon-comment">Tokenizer: character heuristic (~4 chars/token)</span>

<span class="geon-key">Format</span>              <span class="geon-key">Tokens</span>    <span class="geon-key">Chars</span>    <span class="geon-key">Lines</span>
${''.padEnd(56, '-')}
<span class="geon-value">GEON</span>                ${String(gt).padStart(6)}   ${String(currentGeon.length).padStart(6)}   ${String(currentGeon.split('\\n').length).padStart(5)}
<span class="geon-value">GeoJSON (pretty)</span>    ${String(jt).padStart(6)}   ${String(currentGeojson.length).padStart(6)}   ${String(currentGeojson.split('\\n').length).padStart(5)}

<span class="geon-section">ANALYSIS</span>
<span class="geon-list">  GEON saves ${saving}% vs GeoJSON (${jt - gt} fewer tokens)</span>

<span class="geon-comment">Context window capacity (est. places):</span>
  <span class="geon-key">128K:</span>  GEON ~${Math.floor(128000/Math.max(gt,1))}   GeoJSON ~${Math.floor(128000/Math.max(jt,1))}
  <span class="geon-key">200K:</span>  GEON ~${Math.floor(200000/Math.max(gt,1))}   GeoJSON ~${Math.floor(200000/Math.max(jt,1))}`;
}

function estimateTokens(text) { return Math.max(1, Math.round(text.length / 4)); }

function renderValidation() {
  const lines = currentGeon.split('\n').filter(l => l.trim());
  const has = (k) => lines.some(l => l.trim().startsWith(k));
  const ok = has('PLACE:') && has('TYPE:') && has('LOCATION:');
  const missing = ['PURPOSE','EXPERIENCE','SOURCE'].filter(f => !has(f));
  const fc = new Set(lines.filter(l => l.match(/^[A-Z_]+:/)).map(l => l.split(':')[0])).size;
  document.getElementById('validBadge').innerHTML = ok ? '<span class="badge badge-ok">Valid</span>' : '<span class="badge badge-err">Missing required</span>';
  document.getElementById('warnBadge').innerHTML = missing.length > 0 ? `<span class="badge badge-warn">${missing.length} recommended missing</span>` : '<span class="badge badge-ok">All recommended present</span>';
  document.getElementById('fieldsBadge').textContent = `${fc} fields`;
}

// ── Tab / mode switching ─────────────────────────────────────────────────

function switchTab(tab) {
  currentTab = tab;
  document.querySelectorAll('.panel-tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
  if (currentGeon) renderTab();
}

function switchMode() {
  const mode = document.getElementById('modeSelect').value;
  document.getElementById('searchGroup').style.display = mode === 'search' ? 'block' : 'none';
  document.getElementById('searchBtn').style.display = mode === 'search' ? 'inline-block' : 'none';
  document.getElementById('convertBtn').style.display = mode === 'geojson' ? 'inline-block' : 'none';
  document.getElementById('radiusLabel').style.display = mode === 'click' ? '' : 'none';
  document.getElementById('radiusSelect').style.display = mode === 'click' ? '' : 'none';
  const mapEl = document.getElementById('mapContainer'), gj = document.getElementById('geojsonInput');
  if (mode === 'geojson') { mapEl.style.display = 'none'; gj.style.display = 'flex'; }
  else { mapEl.style.display = ''; gj.style.display = 'none'; setTimeout(() => map.invalidateSize(), 100); }
  if (mode === 'search') document.getElementById('searchInput').focus();
}

// ── Actions ──────────────────────────────────────────────────────────────

function copyOutput() {
  const text = currentTab === 'geon' ? currentGeon : currentTab === 'geojson-out' ? currentGeojson : document.getElementById('outputPre').textContent;
  navigator.clipboard.writeText(text).then(() => setStatus('Copied to clipboard'));
}

function downloadGeon() {
  if (!currentGeon) return;
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([currentGeon], { type: 'text/plain' }));
  a.download = 'place.geon'; a.click(); URL.revokeObjectURL(a.href);
}

function clearOutput() {
  currentGeon = ''; currentGeojson = '';
  document.getElementById('emptyState').style.display = '';
  document.getElementById('outputPre').style.display = 'none';
  document.getElementById('validationBar').style.display = 'none';
  markers.clearLayers(); polygons.clearLayers();
  setStatus('Cleared');
}

function toggleHelp() { document.getElementById('helpModal').classList.toggle('active'); }
function setStatus(html) { document.getElementById('statusInfo').innerHTML = html; }
function escHtml(text) { const d = document.createElement('div'); d.textContent = text; return d.innerHTML; }

// ── Resize handle ────────────────────────────────────────────────────────

let isResizing = false;
document.getElementById('resizeHandle').addEventListener('mousedown', (e) => {
  isResizing = true; document.body.style.cursor = 'col-resize'; document.body.style.userSelect = 'none'; e.preventDefault();
});
document.addEventListener('mousemove', (e) => {
  if (!isResizing) return;
  document.getElementById('rightPanel').style.width = Math.max(300, Math.min(800, window.innerWidth - e.clientX)) + 'px';
  map.invalidateSize();
});
document.addEventListener('mouseup', () => { isResizing = false; document.body.style.cursor = ''; document.body.style.userSelect = ''; });
document.addEventListener('keydown', (e) => { if (e.key === 'Escape') document.getElementById('helpModal').classList.remove('active'); });
</script>
</body>
</html>
